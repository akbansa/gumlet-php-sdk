<?php

declare(strict_types=1);

/*
 * GumletRestApisLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

namespace GumletRestApisLib\Models;

use GumletRestApisLib\ApiHelper;
use stdClass;

class VideoProfilesRequest1 implements \JsonSerializable
{
    /**
     * @var string
     */
    private $profileId;

    /**
     * @var string|null
     */
    private $name;

    /**
     * @var string|null
     */
    private $format = Format1Enum::ABR;

    /**
     * @var string|null
     */
    private $width;

    /**
     * @var string|null
     */
    private $height;

    /**
     * @var string|null
     */
    private $resolution;

    /**
     * @var Crop|null
     */
    private $crop;

    /**
     * @var Pad|null
     */
    private $pad;

    /**
     * @var Trim|null
     */
    private $trim;

    /**
     * @var ImageOverlay|null
     */
    private $imageOverlay;

    /**
     * @var TextOverlay|null
     */
    private $textOverlay;

    /**
     * @var AnimatedGif2|null
     */
    private $animatedGif;

    /**
     * @var GenerateSubtitles|null
     */
    private $generateSubtitles;

    /**
     * @var bool|null
     */
    private $mp4Access;

    /**
     * @var bool|null
     */
    private $perTitleEncoding;

    /**
     * @var bool|null
     */
    private $processLowResolutionInput;

    /**
     * @var bool|null
     */
    private $audioOnly;

    /**
     * @var bool|null
     */
    private $enableDrm;

    /**
     * @param string $profileId
     */
    public function __construct(string $profileId)
    {
        $this->profileId = $profileId;
    }

    /**
     * Returns Profile Id.
     * Profile id of the profile which needs to be deleted.
     */
    public function getProfileId(): string
    {
        return $this->profileId;
    }

    /**
     * Sets Profile Id.
     * Profile id of the profile which needs to be deleted.
     *
     * @required
     * @maps profile_id
     */
    public function setProfileId(string $profileId): void
    {
        $this->profileId = $profileId;
    }

    /**
     * Returns Name.
     * Profile name or identifier.
     */
    public function getName(): ?string
    {
        return $this->name;
    }

    /**
     * Sets Name.
     * Profile name or identifier.
     *
     * @maps name
     */
    public function setName(?string $name): void
    {
        $this->name = $name;
    }

    /**
     * Returns Format.
     * Transcode and deliver the asset in the requested format. The options can be one of `ABR` (HLS +
     * DASH) and `MP4`.
     */
    public function getFormat(): ?string
    {
        return $this->format;
    }

    /**
     * Sets Format.
     * Transcode and deliver the asset in the requested format. The options can be one of `ABR` (HLS +
     * DASH) and `MP4`.
     *
     * @maps format
     * @factory \GumletRestApisLib\Models\Format1Enum::checkValue
     */
    public function setFormat(?string $format): void
    {
        $this->format = $format;
    }

    /**
     * Returns Width.
     * Resize video with the given width. Can be an absolute value in pixels or a percentage value with the
     * `%` suffix. Specified values greater than the original asset width will be ignored. Only applicable
     * when specified `format` is `MP4`.
     */
    public function getWidth(): ?string
    {
        return $this->width;
    }

    /**
     * Sets Width.
     * Resize video with the given width. Can be an absolute value in pixels or a percentage value with the
     * `%` suffix. Specified values greater than the original asset width will be ignored. Only applicable
     * when specified `format` is `MP4`.
     *
     * @maps width
     */
    public function setWidth(?string $width): void
    {
        $this->width = $width;
    }

    /**
     * Returns Height.
     * Resize video with the given height. Can be an absolute value in pixels or a percentage value with
     * the `%` suffix. Specified values greater than the original asset height will be ignored. Only
     * applicable when specified `format` is `MP4`.
     */
    public function getHeight(): ?string
    {
        return $this->height;
    }

    /**
     * Sets Height.
     * Resize video with the given height. Can be an absolute value in pixels or a percentage value with
     * the `%` suffix. Specified values greater than the original asset height will be ignored. Only
     * applicable when specified `format` is `MP4`.
     *
     * @maps height
     */
    public function setHeight(?string $height): void
    {
        $this->height = $height;
    }

    /**
     * Returns Resolution.
     * Resize video with the given height. Can be an absolute value in pixels or a percentage value with
     * the `%` suffix. Specified values greater than the original asset height will be ignored. Only
     * applicable when specified `format` is `MP4`.
     */
    public function getResolution(): ?string
    {
        return $this->resolution;
    }

    /**
     * Sets Resolution.
     * Resize video with the given height. Can be an absolute value in pixels or a percentage value with
     * the `%` suffix. Specified values greater than the original asset height will be ignored. Only
     * applicable when specified `format` is `MP4`.
     *
     * @maps resolution
     */
    public function setResolution(?string $resolution): void
    {
        $this->resolution = $resolution;
    }

    /**
     * Returns Crop.
     * This transformation can be used to crop the video by defining a rectangular area within the
     * dimensions of the output video.
     */
    public function getCrop(): ?Crop
    {
        return $this->crop;
    }

    /**
     * Sets Crop.
     * This transformation can be used to crop the video by defining a rectangular area within the
     * dimensions of the output video.
     *
     * @maps crop
     */
    public function setCrop(?Crop $crop): void
    {
        $this->crop = $crop;
    }

    /**
     * Returns Pad.
     * This transformation can be used to add padding to the video.
     */
    public function getPad(): ?Pad
    {
        return $this->pad;
    }

    /**
     * Sets Pad.
     * This transformation can be used to add padding to the video.
     *
     * @maps pad
     */
    public function setPad(?Pad $pad): void
    {
        $this->pad = $pad;
    }

    /**
     * Returns Trim.
     * Trim transformation can be used to trim videos based on time duration.
     */
    public function getTrim(): ?Trim
    {
        return $this->trim;
    }

    /**
     * Sets Trim.
     * Trim transformation can be used to trim videos based on time duration.
     *
     * @maps trim
     */
    public function setTrim(?Trim $trim): void
    {
        $this->trim = $trim;
    }

    /**
     * Returns Image Overlay.
     * Image overlay can be used to brand a video or add a visual label in the form of an image.
     */
    public function getImageOverlay(): ?ImageOverlay
    {
        return $this->imageOverlay;
    }

    /**
     * Sets Image Overlay.
     * Image overlay can be used to brand a video or add a visual label in the form of an image.
     *
     * @maps image_overlay
     */
    public function setImageOverlay(?ImageOverlay $imageOverlay): void
    {
        $this->imageOverlay = $imageOverlay;
    }

    /**
     * Returns Text Overlay.
     * Text overlay can be used to brand a video or add a label in the form of text.
     */
    public function getTextOverlay(): ?TextOverlay
    {
        return $this->textOverlay;
    }

    /**
     * Sets Text Overlay.
     * Text overlay can be used to brand a video or add a label in the form of text.
     *
     * @maps text_overlay
     */
    public function setTextOverlay(?TextOverlay $textOverlay): void
    {
        $this->textOverlay = $textOverlay;
    }

    /**
     * Returns Animated Gif.
     * Create an animated GIF from a video.
     */
    public function getAnimatedGif(): ?AnimatedGif2
    {
        return $this->animatedGif;
    }

    /**
     * Sets Animated Gif.
     * Create an animated GIF from a video.
     *
     * @maps animated_gif
     */
    public function setAnimatedGif(?AnimatedGif2 $animatedGif): void
    {
        $this->animatedGif = $animatedGif;
    }

    /**
     * Returns Generate Subtitles.
     * Gumlet allows to generate subtitles from the audio stream (use <a href='https://en.wikipedia.
     * org/wiki/List_of_ISO_639_language_codes'> ISO 639-1 </a> Language Codes)
     */
    public function getGenerateSubtitles(): ?GenerateSubtitles
    {
        return $this->generateSubtitles;
    }

    /**
     * Sets Generate Subtitles.
     * Gumlet allows to generate subtitles from the audio stream (use <a href='https://en.wikipedia.
     * org/wiki/List_of_ISO_639_language_codes'> ISO 639-1 </a> Language Codes)
     *
     * @maps generate_subtitles
     */
    public function setGenerateSubtitles(?GenerateSubtitles $generateSubtitles): void
    {
        $this->generateSubtitles = $generateSubtitles;
    }

    /**
     * Returns Mp 4 Access.
     * Creates `mp4` version for download purpose in case of `MPEG-DASH` or `HLS` delivery format.
     * **Default: `false`**
     */
    public function getMp4Access(): ?bool
    {
        return $this->mp4Access;
    }

    /**
     * Sets Mp 4 Access.
     * Creates `mp4` version for download purpose in case of `MPEG-DASH` or `HLS` delivery format.
     * **Default: `false`**
     *
     * @maps mp4_access
     */
    public function setMp4Access(?bool $mp4Access): void
    {
        $this->mp4Access = $mp4Access;
    }

    /**
     * Returns Per Title Encoding.
     * Gumlet analyzes each input video on a wide range of visual aspects. Based on the analysis, it
     * chooses a unique set of transcoding options for processing the video. This ensures that the output
     * video is of optimal size and best quality. **Default: `true`**
     */
    public function getPerTitleEncoding(): ?bool
    {
        return $this->perTitleEncoding;
    }

    /**
     * Sets Per Title Encoding.
     * Gumlet analyzes each input video on a wide range of visual aspects. Based on the analysis, it
     * chooses a unique set of transcoding options for processing the video. This ensures that the output
     * video is of optimal size and best quality. **Default: `true`**
     *
     * @maps per_title_encoding
     */
    public function setPerTitleEncoding(?bool $perTitleEncoding): void
    {
        $this->perTitleEncoding = $perTitleEncoding;
    }

    /**
     * Returns Process Low Resolution Input.
     * Currently, the minimum supported frame size is `57600` (`240x240`) pixels for `HLS/DASH` and `21025`
     * (`145x145`) pixels for `MP4` format. However, enabling this flag will allow Gumlet to simply put
     * your video asset into the specified delivery format without transcoding and optimization. Enabling
     * this flag will cause any kind of specified video transformation to be ignored if you input video
     * asset frame size is lower than the minimum supported frame size for the specified format. **Default:
     * `false`**
     */
    public function getProcessLowResolutionInput(): ?bool
    {
        return $this->processLowResolutionInput;
    }

    /**
     * Sets Process Low Resolution Input.
     * Currently, the minimum supported frame size is `57600` (`240x240`) pixels for `HLS/DASH` and `21025`
     * (`145x145`) pixels for `MP4` format. However, enabling this flag will allow Gumlet to simply put
     * your video asset into the specified delivery format without transcoding and optimization. Enabling
     * this flag will cause any kind of specified video transformation to be ignored if you input video
     * asset frame size is lower than the minimum supported frame size for the specified format. **Default:
     * `false`**
     *
     * @maps process_low_resolution_input
     */
    public function setProcessLowResolutionInput(?bool $processLowResolutionInput): void
    {
        $this->processLowResolutionInput = $processLowResolutionInput;
    }

    /**
     * Returns Audio Only.
     * This flag allows Gumlet to transcode and deliver audio-only in the specified format. In this case,
     * This flag allows Gumlet to transcode and deliver audio-only in the specified format. In this case,
     * video transformation and thumbnails/animated GIFs would not be created. **Default: `false`**
     */
    public function getAudioOnly(): ?bool
    {
        return $this->audioOnly;
    }

    /**
     * Sets Audio Only.
     * This flag allows Gumlet to transcode and deliver audio-only in the specified format. In this case,
     * This flag allows Gumlet to transcode and deliver audio-only in the specified format. In this case,
     * video transformation and thumbnails/animated GIFs would not be created. **Default: `false`**
     *
     * @maps audio_only
     */
    public function setAudioOnly(?bool $audioOnly): void
    {
        $this->audioOnly = $audioOnly;
    }

    /**
     * Returns Enable Drm.
     * Enable DRM encryption for transcoded videos. Gumlet supports Widevine and Fairplay DRMs.
     */
    public function getEnableDrm(): ?bool
    {
        return $this->enableDrm;
    }

    /**
     * Sets Enable Drm.
     * Enable DRM encryption for transcoded videos. Gumlet supports Widevine and Fairplay DRMs.
     *
     * @maps enable_drm
     */
    public function setEnableDrm(?bool $enableDrm): void
    {
        $this->enableDrm = $enableDrm;
    }

    /**
     * Converts the VideoProfilesRequest1 object to a human-readable string representation.
     *
     * @return string The string representation of the VideoProfilesRequest1 object.
     */
    public function __toString(): string
    {
        return ApiHelper::stringify(
            'VideoProfilesRequest1',
            [
                'profileId' => $this->profileId,
                'name' => $this->name,
                'format' => $this->format,
                'width' => $this->width,
                'height' => $this->height,
                'resolution' => $this->resolution,
                'crop' => $this->crop,
                'pad' => $this->pad,
                'trim' => $this->trim,
                'imageOverlay' => $this->imageOverlay,
                'textOverlay' => $this->textOverlay,
                'animatedGif' => $this->animatedGif,
                'generateSubtitles' => $this->generateSubtitles,
                'mp4Access' => $this->mp4Access,
                'perTitleEncoding' => $this->perTitleEncoding,
                'processLowResolutionInput' => $this->processLowResolutionInput,
                'audioOnly' => $this->audioOnly,
                'enableDrm' => $this->enableDrm
            ]
        );
    }

    /**
     * Encode this object to JSON
     *
     * @param bool $asArrayWhenEmpty Whether to serialize this model as an array whenever no fields
     *        are set. (default: false)
     *
     * @return array|stdClass
     */
    #[\ReturnTypeWillChange] // @phan-suppress-current-line PhanUndeclaredClassAttribute for (php < 8.1)
    public function jsonSerialize(bool $asArrayWhenEmpty = false)
    {
        $json = [];
        $json['profile_id']                       = $this->profileId;
        if (isset($this->name)) {
            $json['name']                         = $this->name;
        }
        if (isset($this->format)) {
            $json['format']                       = Format1Enum::checkValue($this->format);
        }
        if (isset($this->width)) {
            $json['width']                        = $this->width;
        }
        if (isset($this->height)) {
            $json['height']                       = $this->height;
        }
        if (isset($this->resolution)) {
            $json['resolution']                   = $this->resolution;
        }
        if (isset($this->crop)) {
            $json['crop']                         = $this->crop;
        }
        if (isset($this->pad)) {
            $json['pad']                          = $this->pad;
        }
        if (isset($this->trim)) {
            $json['trim']                         = $this->trim;
        }
        if (isset($this->imageOverlay)) {
            $json['image_overlay']                = $this->imageOverlay;
        }
        if (isset($this->textOverlay)) {
            $json['text_overlay']                 = $this->textOverlay;
        }
        if (isset($this->animatedGif)) {
            $json['animated_gif']                 = $this->animatedGif;
        }
        if (isset($this->generateSubtitles)) {
            $json['generate_subtitles']           = $this->generateSubtitles;
        }
        if (isset($this->mp4Access)) {
            $json['mp4_access']                   = $this->mp4Access;
        }
        if (isset($this->perTitleEncoding)) {
            $json['per_title_encoding']           = $this->perTitleEncoding;
        }
        if (isset($this->processLowResolutionInput)) {
            $json['process_low_resolution_input'] = $this->processLowResolutionInput;
        }
        if (isset($this->audioOnly)) {
            $json['audio_only']                   = $this->audioOnly;
        }
        if (isset($this->enableDrm)) {
            $json['enable_drm']                   = $this->enableDrm;
        }

        return (!$asArrayWhenEmpty && empty($json)) ? new stdClass() : $json;
    }
}
